<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Ikat Visualization</title>
    <style type="text/css">
      div { display: inline; }
      .warp, .weft { fill:none; stroke-width: 10; opacity: 0.5; }
      .weft { stroke: yellow; background-color: yellow; }
      .paint1 { stroke: green; background-color: green; }
      .paint2 { stroke: blue; background-color: blue; }
      .warp { stroke: gray; background-color: gray; }
      svg { border: 1px solid lightgray; }
      canvas#pattern, canvas#pattern2 { border: 1px solid lightgray; }
      canvas#pattern { margin-left: 40px; }
    </style>
  </head>
  <body>
    <p>
      Example pattern:<br>
      (TODO: import any image, scale,
      <a href="https://stackoverflow.com/questions/19129644/how-to-pixelate-an-image-with-canvas-and-javascript">pixelate</a>, and
      <a href="https://stackoverflow.com/questions/6205955/algorithm-for-color-quantization-reduced-image-color-palette-in-javascript">reduce color palette</a> to
      produce a pattern)
    </p>
    <div id="patternarea"></div>
    <p>
      Warp <span class="warp">&nbsp;&nbsp;&nbsp;</span> and
      weft <span class="weft">&nbsp;&nbsp;&nbsp;</span><span class="weft paint1">&nbsp;&nbsp;&nbsp;</span><span class="weft">&nbsp;&nbsp;&nbsp;</span><span class="weft paint2">&nbsp;&nbsp;&nbsp;</span><span class="weft">&nbsp;&nbsp;&nbsp;</span>
	    on a loom:
    </p>
    <div id="svgarea"></div>
    <p>
      <button onclick="resetDrawing(); drawLoom(true)">Animate</button>
    </p>
    <p>
      (dynamic SVG drawing, with JavaScript animation)<br>
    </p>
    <p>
      <pre>
  TODO:
  - show a pattern on the weft
  - from an X × Y pattern matrix, map to back-and-forth weft of Y1 picks of X1 length
  - way to input the various parameters:
      pattern, size of warp, length of weft, visualization details
  - way to export weft pattern in the format needed by the yarn-dyeing machine
  - show weft/warp intersections with weft alternately on top or under warp
      </pre> 
    </p>
    <p>
      More info: <a href="https://en.wikipedia.org/wiki/Warp_and_weft">warp and weft</a>,
      <a href="https://en.wikipedia.org/wiki/Ikat">ikat weaving</a>,
      real-life examples:
      <a href="http://www.arumfellow.com/textiles/solola-ikat-fabric.html">Sololá</a>,
      <a href="http://www.stony-hill-madison.com/solola-old-tzute-with-warp-ikat/">Sololá (warp)</a>,
      <a href="https://www.etsy.com/listing/226266379/ikat-handmade-fabric-59-from-guatemala">more Guatemala</a>,
      <a href="http://blog.apliiq.com/site/ikat/">weft ikat samples</a>,
      <a href="http://www.andreaschewedesign.com/blog/weaving-ikat">Bali</a>.
    </p>
    <p>
      <a href="https://github.com/kaicarver/ikat">Source code on Github</a>.
    </p>
    
    <script type="text/javascript">
      // basic parameters determining size of warp and weft on loom
      var numbackandforths = 5; // weft starts with shuttle from left to right, than x back and forth trips
      var numends = 9; // number of "ends", i.e. vertical lengths of yarn, composing the warp
      var scale = 12; // basic unit of everything
      // calculated parameters
      var numpicks = 1 + 2 * numbackandforths; // total number of "picks", i.e. horizontal lengths of yarn composing the weft
      var i = 2 * scale; // basic interval: space between each vertical warp "end", and each horizontal weft "pick"
      var width = numends * i; // width of the "ends", i.e. straight lines between turns
      var y = i; // vertical position of start of weft
      function autorun() {
	resetDrawing();
	drawPattern();
	drawLoom();
      }
      function drawPattern() {
	// pattern
	var pattern = [
	  [0,0,0,0,0,0,0,0,0],
	  [0,1,0,0,0,1,0,0,0],
	  [1,1,1,0,1,1,1,0,0],
	  [1,2,1,1,1,2,1,1,0],
	  [2,2,2,1,2,2,2,1,1],
	  [2,1,2,2,2,1,2,2,1],
	  [1,1,1,2,1,1,1,2,2],
	  [1,0,1,1,1,0,1,1,2],
	  [0,0,0,1,0,0,0,1,1],
	  [0,0,0,0,0,0,0,0,1],
	  [0,0,0,0,0,0,0,0,0],
	];
	var w = pattern[0].length;
	var h = pattern.length;
	var scale = 20;
	var scale2 = 1;
	console.log(pattern, pattern[0].length + " x " + pattern.length); //JSON.stringify(pattern).replace(/\],\[/g, "],\n[")
	document.getElementById('patternarea').innerHTML =
	  '<canvas id="pattern2" width="'+w+'" height="'+h+'"></canvas>' +
	  '<canvas id="pattern" width="'+w*scale+'" height="'+h*scale+'"></canvas>' +
	  '<br>' + w + ' x ' + h + ' pixels';
	var canvas2 = document.getElementById('pattern2');
	var ctx2 = canvas2.getContext('2d');
	var canvas = document.getElementById('pattern');
	var ctx = canvas.getContext('2d');
	// first draw minimized version of image
	ctx2.fillStyle = 'rgb(256, 256, 0)'; // CSS green
	ctx2.fillRect(0, 0, w, h);
	for (var y = 0; y < h; y++) {
	  for (var x = 0; x < w; x++) {
	    var val = pattern[y][x];
	    if (val != 0) {
	      if (val == 1) {
		ctx2.fillStyle = 'rgb(0, 128, 0)'; // CSS green
	      } else if (val == 2) {
		ctx2.fillStyle = 'rgb(0, 0, 255)'; // CSS blue
	      }
	      ctx2.fillRect(scale2*x, scale2*y, scale2, scale2);
	    }
	  }
	}
	// debug: read the minimized image
	for (var y = 0; y < h; y++) {
	  for (var x = 0; x < w; x++) {
	    var pixel = ctx2.getImageData(x, y, 1, 1);
	    console.log(x, y, pixel.data);
	  }
	}
	// make a copy scaling up the minimized version to a viewable size
	// turn off image aliasing, otherwise the scaling result is all blurry
	ctx.imageSmoothingEnabled = false;
	// enlarge the minimized image to full size    
	ctx.drawImage(canvas2, 0, 0, w, h, 0, 0, canvas.width, canvas.height);
	// debug: save canvas as an image
	var img = canvas.toDataURL("image/png");
	document.write('<img src="'+img+'"/>');
      }
      function normalizeColor(data) {
	//if (data[0] == 0 && data[1] == 0 
      }
      function drawLoom(drawDelayed) {
	// drawDelayed parameter implements a Javascript animation when true
	// TODO: because can't specify z-order in SVG, have to draw warp and weft intertwined, not one after the other
	// draw warp
	setDrawDelayed(drawDelayed);
	setDelayInterval(50);
	drawPart('<symbol id="oneend"><polyline class="warp" points="'+(1.5*i)+','+(0.5*i)+' '+(1.5*i)+','+((numpicks+1)*i)+'" /></symbol>'); // define one "end"
	// draw the specified number of ends
	for (var end = 0; end < numends; end++) {
	  drawPart('<use x="'+(end*i)+'" y="0" xlink:href="#oneend" />');
	}
	// draw weft
	setDelayInterval(100);
	drawEnd(0);
	for (var pick = 0; pick < numpicks; pick++) {
	  drawPick(pick);
	  if (pick < numpicks - 1) {
	    drawCurve(pick);
	  }
	}
	drawEnd(pick-1);
	if (!drawDelayed) {
	  drawBuffer();
	}
      }
      var bufferedDraw = false;
      var delayedDraw = true;
      var delay = 0;
      var delayInterval = 100;
      var bufferedSVG = '';
      function setDrawDelayed(delayed) {
	if (delayed) {
	  setDrawBuffered(false);
	  delayedDraw = true;
	} else {
	  // buffered draw, all in one go
	  setDrawBuffered(true);
	  delayedDraw = false;
	}
      }
      function setDrawBuffered(bool) {
	bufferedDraw = bool;
      }
      function setDelayInterval(millisec) {
	delayInterval = millisec;
      }
      function drawEnd(pick) {
	var yy = y+(pick*i);
	if (pick == 0 || pick%2 == 1) {
	  // first pick starts straight from left, goes towards right
	  // last pick is the same if an odd-numbered pick (should be from right to left, but whatever)
	  drawPart(drawPath('weft', 'M'+(i/4)+','+yy+' '+(i)+','+yy+' '));
	} else {
	  // last pick ends straight at right end
	  drawPart(drawPath('weft', 'M '+(i+width)+','+(yy)+' '+(i+width+3/4*i)+','+(yy)+' '));
	}
      }
      function drawPick(pick) {
	var yy = y+(pick*i);
	if (pick%2 == 1) {
	  // pick crosses loom from right to left
	  drawPart(drawPath('weft paint1', 'M'+(i+width)+','+(yy)+' '+(i+width/2)+','+(yy)+' '));
	  drawPart(drawPath('weft', 'M'+(i+width/2)+','+(yy)+' '+i+','+(yy)+' '));
	} else {
	  // pick crosses loom from left to right
	  drawPart(drawPath('weft paint2', 'M '+i+','+(yy)+' '+(i+width/2)+','+(yy)+' '));
	  drawPart(drawPath('weft', 'M '+(i+width/2)+','+(yy)+' '+(i+width)+','+(yy)+' '));
	}
      }
      function drawCurve(pick) {
	var yy = y+(pick*i);
	if (pick%2 == 0) {	
	  drawPart(drawPath('weft', 'M'+(i+width)+','+(yy)+' A'+(i/2)+','+(i/2)+' 0 1,1 '+(i+width)+','+(yy+i)+' ')); // right side half-circle
	} else {
	  drawPart(drawPath('weft', 'M '+i+','+(yy)+' A'+(i/2)+','+(i/2)+' 0 1,0  '+i+','+(yy+i)+' ')); // left side half-circle
	}
      }
      function drawPath(classname, description) {
	var p = '';
	p += '<path class="'+classname+'" d="';
	p += description;
	p += '" />';
	return p;
      }
      function drawPart(part) {
	if (bufferedDraw) {
	  bufferedSVG += part;
	} else {
	  if (delayedDraw) {
	    setTimeout(function(){ displayPath(part); }, delay);
	    delay += delayInterval;
	  } else {
	    displayPath(part);
	  }
	}
      }
      function drawBuffer() {
	displayPath(bufferedSVG);
	bufferedSVG = '';
      }
      function displayPath(path) {
	document.getElementById('loom').innerHTML += path;
      }
      function resetDrawing() {
	delay = 0;
	var width = (numends + 3) * scale * 2;
	var height = (numpicks + 2.5) * scale * 2;
	document.getElementById('svgarea').innerHTML =
	  '<svg id="loom" viewBox="-'+scale+' -'+scale+' '+width+' '+height+'" width="'+width+'" height="'+height+'">' +
	  'Sorry, your browser does not support inline SVG.' +
	  '</svg>' +
	  '<br>' + numends + ' ends x ' + numpicks + ' picks';

	clearPath();
      }
      function clearPath() {
	document.getElementById('loom').innerHTML = '';
      }
      if (document.addEventListener) document.addEventListener("DOMContentLoaded", autorun, false);
      else if (document.attachEvent) document.attachEvent("onreadystatechange", autorun);
      else window.onload = autorun;
  </script>
  </body>
</html>
