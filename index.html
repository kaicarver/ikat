<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Ikat Visualization</title>
    <style type="text/css">
      div { display: inline; }
      .warp, .weft { fill:none; stroke-width: 10; }
      .weft { stroke: red;  color: red; opacity: 0.5; }
      .warp { stroke: gray; color: gray; opacity: 0.5; }
    </style>
  </head>
  <body>
    <p><span class="warp">Warp</span> and <span class="weft">weft</span> on a loom, dynamic SVG drawing, with JavaScript animation:</p>
    <div>
      <svg id="loom" height="300" width="350">
      Sorry, your browser does not support inline SVG.
      </svg>
    </div>
    <p>
      <button onclick="resetDrawing(); drawLoom(true)">Animate</button>
    </p>
    <p>
      <pre>
	TODO:
	- show a pattern on the weft
	- show weft/warp intersections with weft alternately on top or under warp
	- way to input the various parameters:
	    pattern, size of warp, length of weft, visualization details
	- way to export weft pattern in the format needed by the yarn-dyeing machine...
      </pre>
    </p>
    <p>
      More info: <a href="https://en.wikipedia.org/wiki/Warp_and_weft">warp and weft</a>,
      <a href="https://en.wikipedia.org/wiki/Ikat">ikat weaving</a>.
      <a href="https://github.com/kaicarver/ikat">Source code</a>.
    </p>
    
  <script type="text/javascript">
      function autorun() {
	drawLoom();
      }
      // basic parameters determining size of warp and weft on loom
      var numbackandforths = 5; // weft starts with shuttle from left to right, than x back and forth trips
      var numends = 11; // number of "ends", i.e. vertical lengths of yarn, composing the warp
      var scale = 12; // basic unit of everything
      // calculated parameters
      var numpicks = 1 + 2 * numbackandforths; // total number of "picks", i.e. horizontal lengths of yarn composing the weft
      var i = 2 * scale; // basic interval: space between each vertical warp "end", and each horizontal weft "pick"
      var width = numends * i; // width of the "ends", i.e. straight lines between turns
      var y = i; // vertical position of start of weft
      function drawLoom(drawDelayed) {
	// drawDelayed parameter implements a Javascript animation when true
	// draw
	// TODO: because can't specify z-order in SVG, have to draw warp and weft intertwined, not one after the other
	// draw warp
	setDrawDelayed(drawDelayed);
	setDelayInterval(50);
	drawPart('<symbol id="oneend"><polyline class="warp" points="'+(1.5*i)+','+(0.5*i)+' '+(1.5*i)+','+((numpicks+1)*i)+'" /></symbol>'); // define one "end"
	// draw the specified number of ends
	for (var end = 0; end < numends; end++) {
	  drawPart('<use x="'+end*i+'"  y="0" xlink:href="#oneend" />');
	}
	// draw weft
	setDelayInterval(100);
	drawEnd(0);
	for (var pick = 0; pick < numpicks; pick++) {
	  drawPick(pick)
	  if (pick < numpicks - 1) {
	    drawCurve(pick);
	  }
	}
	drawEnd(pick-1);
	if (!drawDelayed) {
	  drawBuffer();
	}
      }
      var bufferedDraw = false;
      var delayedDraw = true;
      var delay = 0;
      var delayInterval = 100;
      var bufferedSVG = '';
      function setDrawDelayed(delayed) {
	if (delayed) {
	  setDrawBuffered(false);
	  delayedDraw = true;
	} else {
	  // buffered draw, all in one go
	  setDrawBuffered(true);
	  delayedDraw = false;
	}
      }
      function setDrawBuffered(bool) {
	bufferedDraw = bool;
      }
      function setDelayInterval(millisec) {
	delayInterval = millisec;
      }
      function drawEnd(pick) {
	var yy = y+(pick*i);
	if (pick == 0 || pick%2 == 1) {
	  drawPart(drawPath('M'+(i/4)+','+yy+' '+(i)+','+yy+' ')); // first pick starts straight, crosses loom from left to right
	} else {
	  drawPart(drawPath('M '+(i+width)+','+(yy)+' '+(i+width+3/4*i)+','+(yy)+' ')); // last pick ends straight
	}
      }
      function drawPick(pick) {
	var yy = y+(pick*i);
	if (pick%2 == 1) {
	  drawPart(drawPath('M'+(i+width)+','+(yy)+' '+i+','+(yy)+' ')); // pick crosses loom from right to left
	} else {
	  drawPart(drawPath('M '+i+','+(yy)+' '+(i+width)+','+(yy)+' ')); // pick crosses loom from left to right
	}
      }
      function drawCurve(pick) {
	var yy = y+(pick*i);
	if (pick%2 == 0) {	
	  drawPart(drawPath('M'+(i+width)+','+(yy)+' A'+(i/2)+','+(i/2)+' 0 1,1 '+(i+width)+','+(yy+i)+' ')); // right side half-circle
	} else {
	  drawPart(drawPath('M '+i+','+(yy)+' A'+(i/2)+','+(i/2)+' 0 1,0  '+i+','+(yy+i)+' ')); // left side half-circle
	}
      }
      function drawPath(description) {
	var p = '';
	p += '<path class="weft" d="';
	p += description;
	p += '" />';
	return p;
      }
      function drawPart(part) {
	if (bufferedDraw) {
	  bufferedSVG += part;
	} else {
	  if (delayedDraw) {
	    setTimeout(function(){ displayPath(part); }, delay);
	    delay += delayInterval;
	  } else {
	    displayPath(part);
	  }
	}
      }
      function drawBuffer() {
	displayPath(bufferedSVG);
	bufferedSVG = '';
      }
      function displayPath(path) {
	document.getElementById('loom').innerHTML += path;
      }
      function resetDrawing() {
	delay = 0;
	clearPath();
      }
      function clearPath() {
	document.getElementById('loom').innerHTML = '';
      }
      if (document.addEventListener) document.addEventListener("DOMContentLoaded", autorun, false);
      else if (document.attachEvent) document.attachEvent("onreadystatechange", autorun);
      else window.onload = autorun;
  </script>
  </body>
</html>
